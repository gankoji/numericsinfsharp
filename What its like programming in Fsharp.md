# For most problems, it's a blast!
When I first started this project back in January, I already had some experience working with ML-family languages. I actually had worked with SMLNJ over the summer last year as part of the [Programming Languages, Part A | Coursera](https://www.coursera.org/learn/programming-languages) course. Thus, I didn't have to suffer through as much pain as someone coming fresh to F# with no functional or ML experience would have to. 

That said, I still did struggle for a little while. The first couple assignments were reasonably difficult to pull off! This was due to two major reasons: 1) The assignments I was doing and algorithms I was implementing (optimization of smooth functions) were actually somewhat difficult to reason about, and 2) I still wasn't really familiar with the language or how to go about designing an implementation and knocking it out. Thankfully, both of those problems subsided as the semester went on. The problems actually got slightly easier since the topics changed (random sampling, monte carlo and markov chain methods), and I grew into working with F#. 

I still find myself reaching out to google or the API docs to make sure I'm getting the order of arguments to one of the higher order functions right, or to find a library call I think would be handy. To be fair, though, I still do that when I'm writing C#, and that's my day job! I have found that over the last two days where I've been writing the solutions to homeworks 4 and 5, though, that my speed in F# is actually starting to approach that of my speed in Python. I'd say at this point, I'm at roughly the same speed in F# as in C#. 

So, what's good about it, now that I've had 4 months and change to get used to it? Well, there's the usual benefits of functional programming: 
- Immutability by default eliminates an entire *class* of bugs that you could write, so debugging tends to go much easier
- Debugging is also aided by the type system. The compiler is *super* strict about types, often to the programmer's chagrin! This is a bit of a double edged sword, but so far I've seen the maxim 'If it compiles, it probably works!' hold true for this work
- Recursion as a method for looping/repetition is actually pretty slick once you get used to it. I've found it to be a little bit more expressive, while also encouraging me to think harder about what data I really want being passed around between recursions/loop iterations. You can't be quite as lazy as with loops (F# has loops by the way, I just chose not to use them since they more or less force you to use mutation), but they end up being just that little bit slicker
- **Performance**. Obviously, I have a small sample size here, but everytime I've compared Python and F# directly, the runtime speed and even the accuracy of the computation have been significantly better in F#. In one case the speed gain was more than 25x. 

Okay, so what about the bad stuff? Surely it's not all sunshine and rainbows! Of course it's not. 
- The type system. It really is a double edged sword: the compiler's fussiness over types is hardly pleasant to deal with, especially when you're new to the language and not familiar with solving typing errors. 
- Immutability/recursion as defaults are actually a challenge to get used to. Once you do, I don't think this is a real detraction from the good, but it's certainly an obstacle to overcome. 
- Lack of library support/documentation. I hesitate to call this 'lack of library support', because the .NET ecosystem is *huge*. Really, it's more a matter that I generally had more trouble tracking down the right library to use for a particular task (especially for matrix computations! there are multiple competitors, no clear/easy to find best solution)
	- More often than not the documentation that accompanies a .NET library that's not developed and maintained by Microsoft is garbage. 
	- However! There seems to be a growing movement toward bringing most of the capabilities of the SciPy stack to .NET. [SciSharp STACK](https://scisharp.github.io/SciSharp/). Sadly, not all of the projects are getting a lot of love right now, and some of them have been dormant long enough for me to worry about them going forward.
	- It does look like some of the pieces (NumPy in particular) are 'feature complete' ports. Really, they're just compiled C libraries that have wrappers to hook into the .NET platform, but hey that's pretty good as long as they work!